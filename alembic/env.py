"""Alembic environment configuration for async PostgreSQL migrations.

Supports both online (connected) and offline (SQL generation) modes.
Uses SQLModel metadata for autogenerate support.
"""

import asyncio
from logging.config import fileConfig

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config
from sqlmodel import SQLModel

from sibyl.config import settings

# Import all models to ensure they're registered with SQLModel.metadata
from sibyl.db.models import (  # noqa: F401
    ApiKey,
    AuditLog,
    CrawledDocument,
    CrawlSource,
    DeviceAuthorizationRequest,
    DocumentChunk,
    LoginHistory,
    OAuthConnection,
    Organization,
    OrganizationInvitation,
    OrganizationMember,
    PasswordResetToken,
    Team,
    TeamMember,
    User,
    UserSession,
)

# Alembic Config object
config = context.config


def process_revision_directives(
    context: context,  # type: ignore[name-defined]
    revision: tuple[str, ...],
    directives: list,
) -> None:
    """Post-process autogenerated migration directives.

    Filters out FK operations that are cosmetic (same columns, different name/ondelete).
    This prevents noisy migrations from FK naming differences.
    """
    if not directives:
        return

    script = directives[0]
    if script.upgrade_ops is None:
        return

    # Track FK operations to filter
    fk_adds: dict[tuple, object] = {}  # (table, cols) -> operation
    fk_removes: dict[tuple, object] = {}

    for op in list(script.upgrade_ops.ops):
        op_type = type(op).__name__

        if op_type == "DropConstraintOp" and getattr(op, "constraint_type", None) == "foreignkey":
            # FK being dropped
            key = (op.table_name, tuple(sorted(getattr(op, "column_names", []) or [])))
            fk_removes[key] = op
        elif op_type == "CreateForeignKeyOp":
            # FK being added
            key = (op.source_table, tuple(sorted(op.local_cols or [])))
            fk_adds[key] = op

    # Remove pairs where both add and remove exist (cosmetic change)
    ops_to_remove = set()
    for key in fk_adds:
        if key in fk_removes:
            ops_to_remove.add(id(fk_adds[key]))
            ops_to_remove.add(id(fk_removes[key]))

    # Filter operations
    script.upgrade_ops.ops = [op for op in script.upgrade_ops.ops if id(op) not in ops_to_remove]

# Configure logging from alembic.ini
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Set database URL from settings (overrides alembic.ini)
config.set_main_option("sqlalchemy.url", settings.postgres_url)

# SQLModel metadata for autogenerate
target_metadata = SQLModel.metadata


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    Generates SQL scripts without database connection.
    Useful for generating migration SQL for review before applying.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
        compare_server_default=True,
        process_revision_directives=process_revision_directives,
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    """Execute migrations within a connection context."""
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,
        compare_server_default=True,
        process_revision_directives=process_revision_directives,
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """Run migrations asynchronously.

    Creates an async engine and runs migrations within
    an async connection context.
    """
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode with async support.

    Uses asyncio to run migrations against a live database.
    """
    asyncio.run(run_async_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
